<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>从零开始的Vulkan（二）:交换链与命令缓冲区 | 缪之灵</title><meta name="author" content="Illurin"><meta name="copyright" content="Illurin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一切为了渲染：交换链的创建 在此，我们将完成以下三件事：  为Win32平台上的Vulkan应用创建一个前置对象表面（Surface）。 创建一个符合我们需求的用于渲染和呈递图像的交换链。 创建交换链图像视图，它将用于对应我们在交换链上设置的图像。  前置对象表面surface 一般情况，不同平台开发的应用程序都有其各自的执行逻辑，例如在Win32下，一个窗口程序的创建和运行就需要窗口进程，窗口句">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始的Vulkan（二）:交换链与命令缓冲区">
<meta property="og:url" content="https://illurin.github.io/articles/vulkan02/index.html">
<meta property="og:site_name" content="缪之灵">
<meta property="og:description" content="一切为了渲染：交换链的创建 在此，我们将完成以下三件事：  为Win32平台上的Vulkan应用创建一个前置对象表面（Surface）。 创建一个符合我们需求的用于渲染和呈递图像的交换链。 创建交换链图像视图，它将用于对应我们在交换链上设置的图像。  前置对象表面surface 一般情况，不同平台开发的应用程序都有其各自的执行逻辑，例如在Win32下，一个窗口程序的创建和运行就需要窗口进程，窗口句">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://illurin.github.io/images/articles/cover_0.jpg">
<meta property="article:published_time" content="2022-10-14T15:52:57.000Z">
<meta property="article:modified_time" content="2022-11-30T05:55:25.983Z">
<meta property="article:author" content="Illurin">
<meta property="article:tag" content="计算机图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://illurin.github.io/images/articles/cover_0.jpg"><link rel="shortcut icon" href="/images/icon.png"><link rel="canonical" href="https://illurin.github.io/articles/vulkan02/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从零开始的Vulkan（二）:交换链与命令缓冲区',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-30 13:55:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="/css/center-atom.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fa-solid fa-code"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/articles/cover_0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">缪之灵</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fa-solid fa-code"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从零开始的Vulkan（二）:交换链与命令缓冲区</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-14T15:52:57.000Z" title="发表于 2022-10-14 23:52:57">2022-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-30T05:55:25.983Z" title="更新于 2022-11-30 13:55:25">2022-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Vulkan/">Vulkan</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从零开始的Vulkan（二）:交换链与命令缓冲区"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一切为了渲染：交换链的创建">一切为了渲染：交换链的创建</h2>
<p>在此，我们将完成以下三件事：</p>
<ol>
<li>为Win32平台上的Vulkan应用创建一个前置对象表面（Surface）。</li>
<li>创建一个符合我们需求的用于渲染和呈递图像的交换链。</li>
<li>创建交换链图像视图，它将用于对应我们在交换链上设置的图像。</li>
</ol>
<h3 id="前置对象表面surface">前置对象表面surface</h3>
<p>一般情况，不同平台开发的应用程序都有其各自的执行逻辑，例如在Win32下，一个窗口程序的创建和运行就需要窗口进程，窗口句柄，实例句柄和各种消息循环。为了标记一个Win32程序，我们需要得到对应的hWnd和hInstance，然后就可以将Vulkan和Win32程序系绑在一起。</p>
<p>以下宏确保了Vulkan对于Win32平台的正确识别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VK_USE_PLATFORM_WIN32_KHR</span></span><br></pre></td></tr></table></figure>
<p>Khronos为了实现跨平台的目标，为不同平台创造了一个统一的抽象层，名为surface，它是将Vulkan和具体设备显示连接起来的一个桥梁，这里我展示了在win32平台下创建surface的方法，其它平台也是类似的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> surfaceInfo = vk::<span class="built_in">Win32SurfaceCreateInfoKHR</span>()</span><br><span class="line">		.<span class="built_in">setHwnd</span>(hWnd)</span><br><span class="line">		.<span class="built_in">setHinstance</span>(hInstance);</span><br><span class="line"><span class="keyword">if</span> (vkInfo.instance.<span class="built_in">createWin32SurfaceKHR</span>(&amp;surfaceInfo, <span class="number">0</span>, &amp;vkInfo.surface) != vk::Result::eSuccess) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到surface之后，我们需要获取相关信息，方便接下来交换链的创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询surface支持的格式</span></span><br><span class="line"><span class="type">uint32_t</span> formatCount = <span class="number">0</span>;</span><br><span class="line">vkInfo.gpu.<span class="built_in">getSurfaceFormatsKHR</span>(vkInfo.surface, &amp;formatCount, <span class="built_in">static_cast</span>&lt;vk::SurfaceFormatKHR*&gt;(<span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">if</span> (formatCount == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::vector&lt;vk::SurfaceFormatKHR&gt; <span class="title">surfaceFormats</span><span class="params">(formatCount)</span></span>;</span><br><span class="line">vkInfo.gpu.<span class="built_in">getSurfaceFormatsKHR</span>(vkInfo.surface, &amp;formatCount, surfaceFormats.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询surface支持的呈递渲染图像模式</span></span><br><span class="line"><span class="type">uint32_t</span> presentModeCount = <span class="number">0</span>;</span><br><span class="line">vkInfo.gpu.<span class="built_in">getSurfacePresentModesKHR</span>(vkInfo.surface, &amp;presentModeCount, <span class="built_in">static_cast</span>&lt;vk::PresentModeKHR*&gt;(<span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">if</span> (presentModeCount == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::vector&lt;vk::PresentModeKHR&gt; <span class="title">presentModes</span><span class="params">(presentModeCount)</span></span>;</span><br><span class="line">vkInfo.gpu.<span class="built_in">getSurfacePresentModesKHR</span>(vkInfo.surface, &amp;presentModeCount, presentModes.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得surface的相关参数信息</span></span><br><span class="line">vk::SurfaceCapabilitiesKHR surfaceCapabilities;</span><br><span class="line">vkInfo.gpu.<span class="built_in">getSurfaceCapabilitiesKHR</span>(vkInfo.surface, &amp;surfaceCapabilities);</span><br></pre></td></tr></table></figure>
<p>之后我们需要找到该surface下用于呈递渲染图像的图形队列族，使用VkPhysicalDevice的getSurfaceSupportKHR方法来实现，这里的做法类似第一节中找到图形队列族的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;vk::Bool32&gt; <span class="title">supportPresents</span><span class="params">(queueFamilyCount)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; queueFamilyCount; i++)</span><br><span class="line">	vkInfo.gpu.<span class="built_in">getSurfaceSupportKHR</span>(i, vkInfo.surface, &amp;supportPresents[i]);</span><br><span class="line">	</span><br><span class="line"><span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; queueFamilyCount; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (vkInfo.queueProp[i].queueFlags &amp; vk::QueueFlagBits::eGraphics) &#123;</span><br><span class="line">		<span class="keyword">if</span> (supportPresents[i] == VK_TRUE) &#123;</span><br><span class="line">			vkInfo.graphicsQueueFamilyIndex = i;</span><br><span class="line">			found = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!found)</span><br><span class="line">	<span class="comment">//Cannot find queue family</span></span><br></pre></td></tr></table></figure>
<p>大部分情况下，呈递队列和图形队列会是同一个（不排除会有特殊情况，需要将它们分开），这个队列将会用于我们后续记录和提交命令，用以下方法从逻辑设备中获取这个队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.device.<span class="built_in">getQueue</span>(vkInfo.graphicsQueueFamilyIndex, <span class="number">0</span>, &amp;vkInfo.queue);</span><br></pre></td></tr></table></figure>
<h3 id="创建交换链">创建交换链</h3>
<p>终于到了踏入渲染领域的时候了，接下来我们的工作就是填满一个庞大的结构体VkSwapchainCreateInfoKHR并藉此创建Swapchain：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> swapchainInfo = vk::<span class="built_in">SwapchainCreateInfoKHR</span>()</span><br><span class="line">		.<span class="built_in">setSurface</span>(vkInfo.surface)</span><br><span class="line">		.<span class="built_in">setImageFormat</span>(vkInfo.format)</span><br><span class="line">		.<span class="built_in">setMinImageCount</span>(vkInfo.frameCount)</span><br><span class="line">		.<span class="built_in">setImageExtent</span>(vk::<span class="built_in">Extent2D</span>(vkInfo.width, vkInfo.height))</span><br><span class="line">		.<span class="built_in">setPreTransform</span>(surfaceCapabilities.currentTransform)</span><br><span class="line">		.<span class="built_in">setPresentMode</span>(vk::PresentModeKHR::eFifo)</span><br><span class="line">		.<span class="built_in">setImageSharingMode</span>(vk::SharingMode::eExclusive)</span><br><span class="line">		.<span class="built_in">setCompositeAlpha</span>(vk::CompositeAlphaFlagBitsKHR::eOpaque)</span><br><span class="line">		.<span class="built_in">setImageColorSpace</span>(surfaceFormats[<span class="number">0</span>].colorSpace)</span><br><span class="line">		.<span class="built_in">setImageUsage</span>(vk::ImageUsageFlagBits::eColorAttachment)</span><br><span class="line">		.<span class="built_in">setImageArrayLayers</span>(<span class="number">1</span>)</span><br><span class="line">		.<span class="built_in">setClipped</span>(<span class="literal">true</span>);</span><br><span class="line">```		</span><br><span class="line"></span><br><span class="line">一些必要的交换链信息都会在这里被填上，下面我将一个个解释这边每个参量的意思。</span><br><span class="line"></span><br><span class="line">* setSurface指向了刚刚创建的前置对象表面surface，将surface和交换链绑在一起。</span><br><span class="line">* setPresentMode指明了交换链上图像的呈递模式，这里我选择fifo模式，即通常意义上的垂直同步，选择的呈递模式必须被surface所支持。</span><br><span class="line">* setImageFormat指明了交换链上的渲染图像保存的格式，对于大部分的SRGB显示屏，我们选择<span class="number">32</span>位UnormRGBA格式，选择错误或surface不支持的格式会导致显示屏上的画面和色彩错误：</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vkInfo.format = vk::Format::eR8G8B8A8Unorm;</span><br></pre></td></tr></table></figure>
<ul>
<li>setMinImageCount指明了交换链中用与交换的图像个数，如果presentMode是SharedContinuousRefresh或SharedDemandRefresh，则必须设为1，否则必须大于等于surface支持的最小图像个数，这里直接设置相等：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.frameCount = surfaceCapabilities.minImageCount;</span><br></pre></td></tr></table></figure>
<ul>
<li>setImageExtent指明了用于渲染的图像的宽高属性，必须在surface支持的minImageExtent和maxImageExtent之间，一般直接使用窗口的分辨率。</li>
<li>setPreTransform指明了图像的预变换，与surface的变换保持一致，一般为默认（即无变换）。</li>
<li>setImageSharingMode指明了交换链上图像和队列的从属模式，若图像队列和呈递队列为相同队列，则填入exclusive，若不相同，则填入concurrent模式。</li>
<li>setCompositeAlpha指明了图像的Alpha通道将如何处置，这里我不想要渲染出的图像具有透明属性，所以填入opaque，除了这个选项以外还有inherit（继承），PostMultiplied（后乘法），PreMultiplied（前乘法）。</li>
<li>setImageColorSpace指明了图像的色彩空间，这里与surface保持一致，通常是SRGB非线性空间。</li>
<li>setImageUsage指明了交换链上图像的使用方式，这里当然是作颜色附件（ColorAttachment），不同的Attachment将在后文提到。</li>
<li>setImageArrayLayers指明了每个图像所包含的层次，通常来说它的值为1，但对于VR相关的应用程序来说，会使用更多的层次，但这里我们不会提及。</li>
<li>setClipped指明了是否开启剔除，开启后表示不关心图像中被遮挡的像素，这会让程序得到一些优化，但可能会影响像素的回读。<br>
之后，我们终于可以将交换链创建出来了：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vkInfo.device.<span class="built_in">createSwapchainKHR</span>(&amp;swapchainInfo, <span class="number">0</span>, &amp;vkInfo.swapchain) != vk::Result::eSuccess) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换链图像视图Swapchain-Image-View">交换链图像视图Swapchain Image View</h3>
<p>在创建交换链的同时，我们也创建了交换链上的图像，这些图像将在被渲染之后由交换链不断地向显示器循环呈递。图像资源在Vulkan中以VkImage的形式存在，但若要让这些图像资源可以被GPU访问，我们必须为其创建对应的<strong>图像视图（Image View）</strong> 来规定图像资源具体的用法，简单来说就是一个图像对应一个图像视图，因此接下来我们必须创建交换链图像视图。</p>
<p>用以下方法从交换链中获取对应图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.swapchainImages.<span class="built_in">resize</span>(vkInfo.frameCount);</span><br><span class="line">vkInfo.device.<span class="built_in">getSwapchainImagesKHR</span>(vkInfo.swapchain, &amp;vkInfo.frameCount, vkInfo.swapchainImages.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>
<p>接着为交换链上的每一个图像创建一个图像视图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.swapchainImageViews.<span class="built_in">resize</span>(vkInfo.frameCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vkInfo.frameCount; i++) &#123;</span><br><span class="line">	<span class="keyword">auto</span> createInfo = vk::<span class="built_in">ImageViewCreateInfo</span>()</span><br><span class="line">		.<span class="built_in">setViewType</span>(vk::ImageViewType::e2D)</span><br><span class="line">		.<span class="built_in">setSubresourceRange</span>(vk::<span class="built_in">ImageSubresourceRange</span>(vk::ImageAspectFlagBits::eColor, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">		.<span class="built_in">setFormat</span>(vkInfo.format)</span><br><span class="line">		.<span class="built_in">setImage</span>(vkInfo.swapchainImages[i])</span><br><span class="line">		.<span class="built_in">setComponents</span>(vk::<span class="built_in">ComponentMapping</span>(vk::ComponentSwizzle::eIdentity, vk::ComponentSwizzle::eIdentity, vk::ComponentSwizzle::eIdentity, vk::ComponentSwizzle::eIdentity));</span><br><span class="line">	<span class="keyword">if</span> (vkInfo.device.<span class="built_in">createImageView</span>(&amp;createInfo, <span class="number">0</span>, &amp;vkInfo.swapchainImageViews[i]) != vk::Result::eSuccess) &#123;</span><br><span class="line">		<span class="comment">//Error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VkImageViewCreateInfo难理解的部分并不多，接下来就稍作讲解：</p>
<ul>
<li>setViewType指明了图像的种类，有2D贴图，3D贴图，贴图数组，正方体贴图，正方体贴图数组等，这里只需简单的2D贴图。</li>
<li>setFormat指明了图像的格式，这里需要与交换链的图像格式相同。</li>
<li>setImage指明了图像视图对应图像，这里填之前获取的交换链图像。</li>
<li>setComponents指明了图像的四个色彩通道的映射方式，这里只需让它们的映射方式与原来保持一致，这里填错虽不会对画面有什么影响，但会让验证层疯狂报错。</li>
<li>setSubresourceRange指明了访问图像时的子资源范围，它的定义如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageSubresourceRange</span> &#123;</span><br><span class="line">    VkImageAspectFlags    aspectMask;</span><br><span class="line">    <span class="type">uint32_t</span>              baseMipLevel;</span><br><span class="line">    <span class="type">uint32_t</span>              levelCount;</span><br><span class="line">    <span class="type">uint32_t</span>              baseArrayLayer;</span><br><span class="line">    <span class="type">uint32_t</span>              layerCount;</span><br><span class="line">&#125; VkImageSubresourceRange;</span><br></pre></td></tr></table></figure>
<p>aspectMask位掩码指定视图中包含图像的哪些方面，包括颜色，深度，模板等，这里指明为颜色。后面的baseMipLevel和levelCount指明了对图像Mipmap的访问范围，baseArrayLayer和layerCount指明了对贴图数组的读写范围，在这里既没有Mipmap也没有贴图数组，所以都是(0,1)即可。</p>
<h3 id="提交交换链">提交交换链</h3>
<p>在渲染的最后，我们需要用以下方法去提交交换链，之后就可以在显示器上显示出图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> presentInfo = vk::<span class="built_in">PresentInfoKHR</span>()</span><br><span class="line">		.<span class="built_in">setPImageIndices</span>(&amp;currentImage)</span><br><span class="line">		.<span class="built_in">setSwapchainCount</span>(<span class="number">1</span>)</span><br><span class="line">		.<span class="built_in">setPSwapchains</span>(&amp;vkInfo.swapchain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vkInfo.queue.<span class="built_in">presentKHR</span>(&amp;presentInfo) != vk::Result::eSuccess) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ImageIndices指定了提交交换链上的哪一个图像，在实际使用时我们需要将交换链上的帧缓冲循环提交，以实现<strong>多重缓冲</strong>技术。</p>
<p>到此，我们的帧缓冲图像视图已经全部创建完毕，关于交换链的事也告一段落。</p>
<h2 id="从CPU走向GPU：命令缓冲区">从CPU走向GPU：命令缓冲区</h2>
<p>现在，我们必须想办法去控制GPU做一些事情了，用术语来讲，便是向GPU提交<strong>命令</strong>，这样的命令有很多种，有的负责让GPU去绘制，查询，清除，转移，有的负责让GPU担当起状态管理的功用，有的则充当GPU和CPU间的同步助手，这些命令在渲染时缺一不可，会全部用到。但目前，我们需要一个存储命令的区域，这便是<strong>命令缓冲区（Command Buffer）</strong>，命令缓冲区是若干命令的集合，它会被提交给适当的硬件队列（Queue）供 GPU 进行处理。</p>
<h3 id="创建命令池和分配命令缓冲区">创建命令池和分配命令缓冲区</h3>
<p>首先，我们使用VkCreateCommandPool()函数创建命令池。通过填写VkCommandPoolCreateInfo结构体来指导要从这个缓冲池中分配的命令缓冲区的相关特性，同时它还可以指明这个命令缓冲区属于哪个队列族，具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vk::CommandPoolCreateInfo commandPoolInfo;</span><br><span class="line">commandPoolInfo.<span class="built_in">setQueueFamilyIndex</span>(vkInfo.graphicsQueueFamilyIndex);</span><br><span class="line">commandPoolInfo.<span class="built_in">setFlags</span>(vk::CommandPoolCreateFlagBits::eResetCommandBuffer);</span><br><span class="line"><span class="keyword">if</span> (vkInfo.device.<span class="built_in">createCommandPool</span>(&amp;commandPoolInfo, <span class="number">0</span>, &amp;vkInfo.cmdPool) != vk::Result::eSuccess) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VkCommandPoolFlag用于指示命令池的使用情况以及从中分配命令缓冲区的行为：ResetCommandBuffer表示从这个池中分配的命令缓冲区可以通过VkResetCommandBuffer显式重置或VkBeginCommandBuffer隐式重置，而若不设置该标志，则命令缓冲区只能通过重置命令池的方式进行重置；transient标志则表示从该池分配的命令缓冲区会被经常更改并且寿命较短，这意味着缓冲区会在相对较短的时间内被重置或释放。</p>
<p>有了命令池之后，便可以轻易地从命令池中分配命令缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.cmd.<span class="built_in">resize</span>(vkInfo.frameCount);</span><br><span class="line">vk::CommandBufferAllocateInfo cmdBufferAlloc;</span><br><span class="line">cmdBufferAlloc.<span class="built_in">setCommandPool</span>(vkInfo.cmdPool);</span><br><span class="line">cmdBufferAlloc.<span class="built_in">setLevel</span>(vk::CommandBufferLevel::ePrimary);</span><br><span class="line">cmdBufferAlloc.<span class="built_in">setCommandBufferCount</span>(vkInfo.frameCount);</span><br><span class="line"><span class="keyword">if</span> (vkInfo.device.<span class="built_in">allocateCommandBuffers</span>(&amp;cmdBufferAlloc, vkInfo.cmd.<span class="built_in">data</span>()) != vk::Result::eSuccess) &#123;</span><br><span class="line">	<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这里分配了和帧缓冲数量相同的命令缓冲区，目的便是为了让一个命令缓冲区处理一个帧缓冲，避免造成冲突。setLevel指明了该命令缓冲区是处于主级还是次级，这里我们只需要让它处于主级。</p>
<blockquote>
<p>主级命令缓冲区可以直接被提交给队列进行执行，而次级命令缓冲区不能直接提交给队列，必须通过主级命令缓冲区来间接执行。每个命令缓冲区之间的执行都是互相独立的，不存在主级和次级之间的继承关系，但它们所处的的生命周期会进行绑定，通过释放主级命令缓冲区可以解除该绑定。<br>
位于不同命令缓冲区之中的命令的执行顺序是任意且不可知的，想要对它们进行排序，则需要同步命令，在之后我们会更详细的用到同步相关的内容。</p>
</blockquote>
<p>用以下方法重置命令池（同时重置分配的命令缓冲区）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkResetCommandPool</span><span class="params">(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ResetReleaseResources标志会使重置命令池时回收命令池中的所有资源。</p>
<p>命令池同样也有对应的Destroy函数，别忘记了。</p>
<h3 id="命令缓冲区行为">命令缓冲区行为</h3>
<p>根据VkSpec的描述，每一个命令缓冲区将会拥有以下的生命周期：</p>
<ol>
<li>起始状态，命令缓冲区刚被分配或重置时就是这个状态，在这个状态下命令缓冲区可以转向记录状态或用vkFreeCommandBuffers方法释放。</li>
<li>记录状态，vkBeginCommandBuffer方法开始了这个状态，在这个状态下，vkCmd*命令将被记录在命令缓冲区中。</li>
<li>可执行状态，vkEndCommandBuffer方法结束了命令的记录，在这个状态下，命令缓冲区可以被提交，重置或记录到另一个命令缓冲区内。</li>
<li>待定状态，命令缓冲区被提交到队列中会使它处于这个状态。在这个状态下，设备正在处理该命令缓冲区，因此不可以尝试任何试图改变该命令缓冲区的方法。此状态结束后，命令缓冲区将恢复到可执行状态，但UsageOnceTimeSubmit标志会使命令缓冲区转向不可用状态。同步命令必须被用于侦测该状态。</li>
<li>不可用状态，一些操作（例如删除或修改命令缓冲区被命令使用的资源）会使命令缓冲区转向这个状态。在这个状态下，命令缓冲区只能被重置或释放。</li>
</ol>
<p><img src="/images/articles/vulkan02/image_0.png" alt="命令缓冲区的生命周期"></p>
<p>以下代码演示了如何完成记录命令到命令缓冲区中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmdBeginInfo = vk::<span class="built_in">CommandBufferBeginInfo</span>()</span><br><span class="line">			.<span class="built_in">setFlags</span>(vk::CommandBufferUsageFlagBits::eOneTimeSubmit);</span><br><span class="line"></span><br><span class="line">vkInfo.cmd[currentBuffer].<span class="built_in">begin</span>(&amp;cmdBeginInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用vkCmd*函数记录命令</span></span><br><span class="line"></span><br><span class="line">vkInfo.cmd[currentBuffer].<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>OneTimeSubmit标志指明命令缓冲区中记录的命令只会被提交一次，且在两次提交之间会被重置和重新记录</li>
<li>RenderPassContinue标志次级命令缓冲区是完全包含在一个渲染过程（RenderPass）中的，该标志对主级缓冲区无效。</li>
<li>SimultaneousUse标志指明命令缓冲区在待定阶段中可以被重复提交，且可以被记录到多个主级命令缓冲区中。</li>
</ul>
<p>以下代码演示了如何提交命令缓冲区到队列中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vk::PipelineStageFlags dstStageMask[] = &#123;</span><br><span class="line">	vk::PipelineStageFlagBits::eBottomOfPipe</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vkInfo.device.<span class="built_in">resetFences</span>(<span class="number">1</span>, &amp;vkInfo.fence);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> submitInfo = vk::<span class="built_in">SubmitInfo</span>()</span><br><span class="line">	.<span class="built_in">setCommandBufferCount</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="built_in">setPCommandBuffers</span>(&amp;vkInfo.cmd[currentBuffer])</span><br><span class="line">	.<span class="built_in">setWaitSemaphoreCount</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="built_in">setPWaitSemaphores</span>(&amp;vkInfo.imageAcquiredSemaphore)</span><br><span class="line">	.<span class="built_in">setPWaitDstStageMask</span>(dstStageMask);</span><br><span class="line">vkInfo.queue.<span class="built_in">submit</span>(<span class="number">1</span>, &amp;submitInfo, vkInfo.fence);</span><br></pre></td></tr></table></figure>
<p>这里用到了Vulkan中特有的Fence和Semaphore功能实现了提交命令缓冲区的同步，关于它们的详细解释会在同步一节中说明。dstStageMask是一个用于标记管线阶段的掩码，在之后讲解图形管线时会再次提到。</p>
<p>在queue.submit函数中有一个类型为vk::ArrayProxy的参数，它是一个作用方式类似于数组的模板类，作用与（count， pointer）相同，我一般用后者这样的写法。</p>
<p>Vulkan1.3中提供了一个新的方法来实现提交，这里不再过多赘述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provided by VK_VERSION_1_3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubmitInfo2</span> &#123;</span><br><span class="line">  VkStructureType sType;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span>* pNext;</span><br><span class="line">  VkSubmitFlags flags;</span><br><span class="line">  <span class="type">uint32_t</span> waitSemaphoreInfoCount;</span><br><span class="line">  <span class="type">const</span> VkSemaphoreSubmitInfo* pWaitSemaphoreInfos;</span><br><span class="line">  <span class="type">uint32_t</span> commandBufferInfoCount;</span><br><span class="line">  <span class="type">const</span> VkCommandBufferSubmitInfo* pCommandBufferInfos;</span><br><span class="line">  <span class="type">uint32_t</span> signalSemaphoreInfoCount;</span><br><span class="line">  <span class="type">const</span> VkSemaphoreSubmitInfo* pSignalSemaphoreInfos;</span><br><span class="line">&#125; VkSubmitInfo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provided by VK_VERSION_1_3</span></span><br><span class="line"><span class="function">VkResult <span class="title">vkQueueSubmit2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  VkQueue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint32_t</span> submitCount,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> VkSubmitInfo2* pSubmits,</span></span></span><br><span class="line"><span class="params"><span class="function">  VkFence fence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在完成命令缓冲区的使用后，可以用以下方法释放命令缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.device.<span class="built_in">freeCommandBuffers</span>(vkInfo.cmdPool, <span class="number">1</span>, &amp;vkInfo.cmd[currentBuffer]);</span><br></pre></td></tr></table></figure>
<h3 id="次级命令缓冲区">次级命令缓冲区</h3>
<p>由于次级命令缓冲区无法直接被提交到队列中，所以必须用以下方法将其绑定到主级命令缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.cmd[currentBuffer].<span class="built_in">executeCommands</span>(<span class="number">1</span>, &amp;secondaryCmd);</span><br></pre></td></tr></table></figure>
<p>VkSpec中指出填写VkCommandBufferInheritanceRenderingInfo（Vulkan1.3）并使用VkCommandBufferInheritanceRenderingInfoKHR方法可以实现次级命令缓冲区对于主级命令缓冲区的继承，大致了解即可，这里不会过多赘述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provided by VK_VERSION_1_0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferInheritanceInfo</span> &#123;</span><br><span class="line">  VkStructureType sType;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span>* pNext;</span><br><span class="line">  VkRenderPass renderPass;</span><br><span class="line">  <span class="type">uint32_t</span> subpass;</span><br><span class="line">  VkFramebuffer framebuffer;</span><br><span class="line">  VkBool32 occlusionQueryEnable;</span><br><span class="line">  VkQueryControlFlags queryFlags;</span><br><span class="line">  VkQueryPipelineStatisticFlags pipelineStatistics;</span><br><span class="line">&#125; VkCommandBufferInheritanceInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provided by VK_VERSION_1_3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferInheritanceRenderingInfo</span> &#123;</span><br><span class="line">  VkStructureType sType;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span>* pNext;</span><br><span class="line">  VkRenderingFlags flags;</span><br><span class="line">  <span class="type">uint32_t</span> viewMask;</span><br><span class="line">  <span class="type">uint32_t</span> colorAttachmentCount;</span><br><span class="line">  <span class="type">const</span> VkFormat* pColorAttachmentFormats;</span><br><span class="line">  VkFormat depthAttachmentFormat;</span><br><span class="line">  VkFormat stencilAttachmentFormat;</span><br><span class="line">  VkSampleCountFlagBits rasterizationSamples;</span><br><span class="line">&#125; VkCommandBufferInheritanceRenderingInfo;</span><br></pre></td></tr></table></figure>
<h3 id="设备掩码">设备掩码</h3>
<p>我们可以通过给命令缓冲区设置设备掩码的方式来决定随后的命令将允许在哪一个物理设备（GPU）上，它可以直接在vkBeginCommandBuffer指定，也可以单独用命令指定。</p>
<p>用vkBeginCommandBuffer方法指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deviceMask = vk::<span class="built_in">DeviceGroupCommandBufferBeginInfo</span>().<span class="built_in">setDeviceMask</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> cmdBeginInfo = vk::<span class="built_in">CommandBufferBeginInfo</span>()</span><br><span class="line">			.<span class="built_in">setPNext</span>(&amp;deviceMask)</span><br><span class="line">			.<span class="built_in">setFlags</span>(vk::CommandBufferUsageFlagBits::eOneTimeSubmit);</span><br><span class="line">vkInfo.cmd[currentBuffer].<span class="built_in">begin</span>(&amp;cmdBeginInfo);</span><br></pre></td></tr></table></figure>
<p>用命令指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkInfo.cmd[currentBuffer].<span class="built_in">setDeviceMask</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>设备掩码主要是用来给不同的物理设备分派不同的任务，从而提高运行效率，具体关于设备掩码的使用方法可以查阅VkSpec。</p>
<p>至此，我们已经了解了命令缓冲区的基本用法，之后我们就可以在绘制时更加如鱼得水地使用它了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://illurin.github.io">Illurin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://illurin.github.io/articles/vulkan02/">https://illurin.github.io/articles/vulkan02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://illurin.github.io" target="_blank">缪之灵</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</a></div><div class="post_share"><div class="social-share" data-image="/images/articles/cover_0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/articles/vulkan01/"><img class="prev-cover" src="/images/articles/cover_0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从零开始的Vulkan（一）：设备与调试</div></div></a></div><div class="next-post pull-right"><a href="/articles/vulkan03/"><img class="next-cover" src="/images/articles/cover_0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从零开始的Vulkan（三）：资源与内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/articles/assimp/" title="Assimp与模型渲染的故事：模型加载，骨骼蒙皮动画"><img class="cover" src="/images/articles/cover_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-15</div><div class="title">Assimp与模型渲染的故事：模型加载，骨骼蒙皮动画</div></div></a></div><div><a href="/articles/renderer01/" title="软光栅化渲染器学习笔记（一）：简单几何图元"><img class="cover" src="/images/gallery/touhou_3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-15</div><div class="title">软光栅化渲染器学习笔记（一）：简单几何图元</div></div></a></div><div><a href="/articles/vulkan01/" title="从零开始的Vulkan（一）：设备与调试"><img class="cover" src="/images/articles/cover_0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-14</div><div class="title">从零开始的Vulkan（一）：设备与调试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Illurin</div><div class="author-info__description">缪之灵的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Illurin"><i class="fab fa-github"></i><span>关注我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Illurin" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://www.zhihu.com/people/96-61-29-67" target="_blank" title="知乎"><i class="fa-brands fa-zhihu"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E4%B8%BA%E4%BA%86%E6%B8%B2%E6%9F%93%EF%BC%9A%E4%BA%A4%E6%8D%A2%E9%93%BE%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">一切为了渲染：交换链的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E8%A1%A8%E9%9D%A2surface"><span class="toc-number">1.1.</span> <span class="toc-text">前置对象表面surface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE"><span class="toc-number">1.2.</span> <span class="toc-text">创建交换链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E9%93%BE%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BESwapchain-Image-View"><span class="toc-number">1.3.</span> <span class="toc-text">交换链图像视图Swapchain Image View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%A4%E6%8D%A2%E9%93%BE"><span class="toc-number">1.4.</span> <span class="toc-text">提交交换链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8ECPU%E8%B5%B0%E5%90%91GPU%EF%BC%9A%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.</span> <span class="toc-text">从CPU走向GPU：命令缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E6%B1%A0%E5%92%8C%E5%88%86%E9%85%8D%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">创建命令池和分配命令缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.2.</span> <span class="toc-text">命令缓冲区行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E7%BA%A7%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.3.</span> <span class="toc-text">次级命令缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A9%E7%A0%81"><span class="toc-number">2.4.</span> <span class="toc-text">设备掩码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/articles/cpp_reflection/" title="使用模板技巧和LibClang实现简易C++静态反射系统"><img src="/images/articles/cpp_reflection/image_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用模板技巧和LibClang实现简易C++静态反射系统"/></a><div class="content"><a class="title" href="/articles/cpp_reflection/" title="使用模板技巧和LibClang实现简易C++静态反射系统">使用模板技巧和LibClang实现简易C++静态反射系统</a><time datetime="2022-12-25T12:30:00.000Z" title="发表于 2022-12-25 20:30:00">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra04/" title="矩阵代数（三）：特征值与二次型"><img src="/images/gallery/arcaea_0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（三）：特征值与二次型"/></a><div class="content"><a class="title" href="/articles/linear-algebra04/" title="矩阵代数（三）：特征值与二次型">矩阵代数（三）：特征值与二次型</a><time datetime="2022-12-24T15:31:00.000Z" title="发表于 2022-12-24 23:31:00">2022-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra03/" title="矩阵代数（二）：秩与线性方程组"><img src="/images/gallery/arcaea_0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（二）：秩与线性方程组"/></a><div class="content"><a class="title" href="/articles/linear-algebra03/" title="矩阵代数（二）：秩与线性方程组">矩阵代数（二）：秩与线性方程组</a><time datetime="2022-12-02T00:38:00.000Z" title="发表于 2022-12-02 08:38:00">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra02/" title="矩阵代数（一）：行列式与矩阵求逆"><img src="/images/gallery/arcaea_0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（一）：行列式与矩阵求逆"/></a><div class="content"><a class="title" href="/articles/linear-algebra02/" title="矩阵代数（一）：行列式与矩阵求逆">矩阵代数（一）：行列式与矩阵求逆</a><time datetime="2022-12-02T00:37:00.000Z" title="发表于 2022-12-02 08:37:00">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra01/" title="线性空间与线性变换概念浅析"><img src="/images/gallery/arcaea_0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性空间与线性变换概念浅析"/></a><div class="content"><a class="title" href="/articles/linear-algebra01/" title="线性空间与线性变换概念浅析">线性空间与线性变换概念浅析</a><time datetime="2022-11-29T12:00:00.000Z" title="发表于 2022-11-29 20:00:00">2022-11-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/articles/cover_0.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Illurin</div><div class="footer_custom_text">Never give up your dream.<br><a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备2022049609号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>