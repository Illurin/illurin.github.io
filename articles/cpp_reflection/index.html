<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>使用模板技巧和LibClang实现简易C++静态反射系统 | 缪之灵</title><meta name="author" content="Illurin"><meta name="copyright" content="Illurin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在游戏引擎的设计中，我们经常会需要从外部去修改在程序代码中定义的变量，例如在代码中定义一个角色的速度，将其曝露在编辑器中，使我们在调试的时候只需要在编辑器中修改对应的值，而不需要每次都修改对应的代码，这种使数据和实现分离的思想是游戏引擎设计中的核心一环。 为了实现这个功能，我们就需要引入反射（Reflection） 的概念。所谓反射，就是指程序可以访问，检测和修改它本身状态或行为的一种能力，而在C">
<meta property="og:type" content="article">
<meta property="og:title" content="使用模板技巧和LibClang实现简易C++静态反射系统">
<meta property="og:url" content="https://illurin.github.io/articles/cpp_reflection/index.html">
<meta property="og:site_name" content="缪之灵">
<meta property="og:description" content="在游戏引擎的设计中，我们经常会需要从外部去修改在程序代码中定义的变量，例如在代码中定义一个角色的速度，将其曝露在编辑器中，使我们在调试的时候只需要在编辑器中修改对应的值，而不需要每次都修改对应的代码，这种使数据和实现分离的思想是游戏引擎设计中的核心一环。 为了实现这个功能，我们就需要引入反射（Reflection） 的概念。所谓反射，就是指程序可以访问，检测和修改它本身状态或行为的一种能力，而在C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://illurin.github.io/images/articles/cpp_reflection/image_1.png">
<meta property="article:published_time" content="2022-12-16T12:30:00.000Z">
<meta property="article:modified_time" content="2022-12-24T15:34:45.453Z">
<meta property="article:author" content="Illurin">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="游戏引擎设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://illurin.github.io/images/articles/cpp_reflection/image_1.png"><link rel="shortcut icon" href="/images/icon.png"><link rel="canonical" href="https://illurin.github.io/articles/cpp_reflection/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用模板技巧和LibClang实现简易C++静态反射系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-24 23:34:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="/css/center-atom.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fa-solid fa-code"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/articles/cpp_reflection/image_1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">缪之灵</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fa-solid fa-code"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa-solid fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用模板技巧和LibClang实现简易C++静态反射系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-16T12:30:00.000Z" title="发表于 2022-12-16 20:30:00">2022-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-24T15:34:45.453Z" title="更新于 2022-12-24 23:34:45">2022-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Modern-C/">Modern C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用模板技巧和LibClang实现简易C++静态反射系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在游戏引擎的设计中，我们经常会需要从外部去修改在程序代码中定义的变量，例如在代码中定义一个角色的速度，将其曝露在编辑器中，使我们在调试的时候只需要在编辑器中修改对应的值，而不需要每次都修改对应的代码，这种使数据和实现分离的思想是游戏引擎设计中的核心一环。</p>
<p>为了实现这个功能，我们就需要引入<strong>反射（Reflection）</strong> 的概念。所谓反射，就是指程序可以访问，检测和修改它本身状态或行为的一种能力，而在C++里，就是可以通过字符串表示的类名找到程序中对应的类，以及访问和修改类中的成员变量/成员函数的功能。</p>
<p>反射的实现主要有以下两个方法：</p>
<ol>
<li>运行时反射：在运行时创建反射的注册表，将所有要反射的类写入注册表中。</li>
<li>编译期反射：给所有要反射的类指定宏，并在编译期自动生成反射类的代码。</li>
</ol>
<p>这里我选择以运行时反射为基础，先成功获取所有的反射信息，之后要进行代码生成或者静态反射就十分容易了。</p>
<h2 id="运行时反射">运行时反射</h2>
<blockquote>
<p>以下代码部分参考RTTR库以及 <a target="_blank" rel="noopener" href="https://github.com/taichi-dev/cpp-training-season1">https://github.com/taichi-dev/cpp-training-season1</a> 实现。</p>
</blockquote>
<h3 id="创建全局注册表">创建全局注册表</h3>
<p>我们需要一个基本的数据结构来描述反射出的类是什么样的，一般而言，它会包括：类名，类的成员变量，类的成员函数。成员变量和成员函数我们分别采用类<code>MemberVariable</code>和<code>MemberFunction</code>来存储，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> ::<span class="function">std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ::<span class="function">std::vector&lt;MemberVariable&gt;&amp; <span class="title">GetMemberVariables</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memberVars;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ::<span class="function">std::vector&lt;MemberFunction&gt;&amp; <span class="title">GetMemberFunctions</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memberFuncs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">MemberVariable <span class="title">GetMemberVariable</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; var : memberVars) &#123;</span><br><span class="line">			<span class="keyword">if</span> (var.<span class="built_in">GetName</span>() == name)</span><br><span class="line">				<span class="keyword">return</span> var;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> MemberVariable&#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">MemberFunction <span class="title">GetMemberFunction</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; func : memberFuncs) &#123;</span><br><span class="line">			<span class="keyword">if</span> (func.<span class="built_in">GetName</span>() == name)</span><br><span class="line">				<span class="keyword">return</span> func;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> MemberFunction&#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	::std::string name;</span><br><span class="line"></span><br><span class="line">	::std::vector&lt;MemberVariable&gt; memberVars;</span><br><span class="line">	::std::vector&lt;MemberFunction&gt; memberFuncs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们创建一个静态的全局注册表，所有需要反射的类都会写入到注册表中，我们可以采用<code>std::unique_ptr</code>来管理全局唯一<code>TypeDescriptor</code>对象，并且使用哈希表方便查找，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Registry&amp; <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> Registry instance;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::vector&lt;TypeDescriptor*&gt; <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		std::vector&lt;TypeDescriptor*&gt; tmpDescs;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; desc : descs) &#123;</span><br><span class="line">			tmpDescs.<span class="built_in">push_back</span>(desc.second.<span class="built_in">get</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmpDescs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">TypeDescriptor* <span class="title">Find</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> descs.<span class="built_in">find</span>(name)-&gt;second.<span class="built_in">get</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Register</span><span class="params">(::std::unique_ptr&lt;TypeDescriptor&gt; desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> name = desc-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">		descs[name] = ::std::<span class="built_in">move</span>(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">decltype</span>(descs) temp;</span><br><span class="line">		descs.<span class="built_in">swap</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	::std::unordered_map&lt;::std::string, ::std::unique_ptr&lt;TypeDescriptor&gt;&gt; descs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>Clear</code>函数中使用了<code>swap</code>来清空容器，这样的好处是可以使容器完全重置，如果直接使用<code>clear</code>的话会保留原来的容器大小。</p>
</blockquote>
<h3 id="类型擦除（Type-Erasure）">类型擦除（Type Erasure）</h3>
<p>在实现反射类成员量的过程中，我们不关心变量/函数的具体类型，我们希望最终写出来的代码可以做到类型无关，泛用性很强，这时候就需要用到<strong>类型擦除</strong>的概念，</p>
<p>类型擦除的一个典型做法就是使用<code>template</code>模板，我们通常使用模板来处理任何类型的变量，也可以用模板来处理任何类型的类，参考以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Var&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(Var Class::* var)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个模板函数的形参<code>var</code>是一个指针，它指向<code>Class</code>类型中的任意一个<code>Var</code>类型的成员变量。假设有一个类<code>Foo</code>，里面有一个<code>int</code>类型的成员变量<code>x</code>，那么我们可以这样调用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Var&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(Var Class::* var, Class obj)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; obj.*var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Foo foo;</span><br><span class="line">	foo.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Function</span>(&amp;Foo::x, foo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模板函数写法让我们可以读写任何类中的任何成员变量，这样就成功将具体的类擦除了。</p>
<p>C++11中的lambda匿名函数可以用于实现类型无关的抽象，参考以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">void</span>* var) &#123;</span><br><span class="line">		func = [var]() -&gt; <span class="type">void</span>* &#123;</span><br><span class="line">			<span class="keyword">return</span> var;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">func</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::function&lt;<span class="type">void</span>* ()&gt; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line">	<span class="function">Foo <span class="title">foo</span><span class="params">(&amp;var)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(foo.<span class="built_in">Func</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++17在STL库中新增的万能容器<code>std::any</code>和<code>std::any_cast</code>可以更方便地实现类型擦除，参考以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;std::any&gt; values;</span><br><span class="line"></span><br><span class="line">	values.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	values.<span class="built_in">push_back</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> print = [](<span class="type">const</span> std::any&amp; value) &#123;</span><br><span class="line">		<span class="comment">//判断 value 是否为 int 类型</span></span><br><span class="line">		<span class="keyword">if</span> (value.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断 value 是否为 string 类型</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">char</span>*)) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果是其它类型，则输出错误信息</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;unkown type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : values) &#123;</span><br><span class="line">		<span class="built_in">print</span>(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>std::any_cast</code>转换的类型与<code>std::any</code>中存储的值的实际类型不符，则会抛出<code>bad_any_cast</code>异常，这也说明<code>std::any_cast</code>本身并不能实现任何类型转换。</p>
<p>值得一提的是，标准中规定以下写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::any var = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(&amp;var);</span><br></pre></td></tr></table></figure>
<p>得到的<code>ptr</code>是一个指向<code>var</code>的指针，即此处cast出的实际类型为<code>int*</code>。</p>
<p>在进行未定类型函数传参时，<code>std::any</code>是对于<code>void*</code>和<code>std::shared_ptr&lt;void&gt;</code>的一个上位替代。</p>
<h3 id="反射成员变量">反射成员变量</h3>
<p>接下来完善我们的<code>MemberVariable</code>类，在此类中我们需要：变量名，获取变量的方法，修改变量的方法。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemberVariable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MemberVariable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Var&gt;</span></span><br><span class="line"><span class="function">	<span class="title">MemberVariable</span><span class="params">(Var Class::* var)</span> </span>&#123;</span><br><span class="line">		getter = [var](::std::any obj) -&gt; ::std::any &#123;</span><br><span class="line">			<span class="keyword">return</span> ::std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> Class*&gt;(obj)-&gt;*var;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		setter = [var](::std::any obj, ::std::any val) &#123;</span><br><span class="line">			<span class="keyword">auto</span>* self = ::std::<span class="built_in">any_cast</span>&lt;Class*&gt;(obj);</span><br><span class="line">			self-&gt;*var = ::std::<span class="built_in">any_cast</span>&lt;Var&gt;(val);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ::<span class="function">std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Var, <span class="keyword">class</span> Class&gt;</span></span><br><span class="line"><span class="function">	Var <span class="title">GetValue</span><span class="params">(<span class="type">const</span> Class&amp; obj)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ::std::<span class="built_in">any_cast</span>&lt;Var&gt;(<span class="built_in">getter</span>(&amp;obj));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Var, <span class="keyword">class</span> Class&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">SetValue</span><span class="params">(Class&amp; obj, Var value)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">setter</span>(&amp;obj, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	::std::string name;</span><br><span class="line"></span><br><span class="line">	::std::function&lt;::std::any(::std::any)&gt; getter&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">	::std::function&lt;<span class="type">void</span>(::std::any, ::std::any)&gt; setter&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在此处我们就使用了类型擦除的技巧，为什么要使用类型擦除，原因也很简单，因为我们的反射是在运行时执行的，在编译期我们并不知道具体的类型，因此不能写出<code>MemberVariable&lt;Class, Var&gt;</code>的形式，这也是便于塞进同一个容器中。</p>
<p>这个类中比较难理解的就是构造函数的代码。在构造函数中，我们首先获得指向类中一个成员变量的指针，并用lambda表达式捕获这个指针，然后初始化<code>getter</code>和<code>setter</code>方法。<code>getter</code>方法输入一个类实例，返回类中对应成员变量的值；<code>setter</code>输入一个类实例和值，修改类实例中对应成员变量的值。</p>
<h3 id="反射成员函数">反射成员函数</h3>
<p>接下来完善我们的<code>MemberFunction</code>类，它和构造<code>MemberVariable</code>的大致思路相同，只不过复杂度要高了一些。我们首先来考虑构造函数：</p>
<p><strong>无返回值，非const成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(<span class="type">void</span> (Class::* func)(Args...))</span> </span>&#123;</span><br><span class="line">	function = [<span class="keyword">this</span>, func](::std::any objArgs) -&gt; ::std::any &#123;</span><br><span class="line">		<span class="keyword">using</span> tuple = ::std::tuple&lt;Class&amp;, Args...&gt;;</span><br><span class="line">		<span class="keyword">auto</span>* pTuple = ::std::<span class="built_in">any_cast</span>&lt;tuple*&gt;(objArgs);</span><br><span class="line">		::std::<span class="built_in">apply</span>(func, *pTuple);</span><br><span class="line">		<span class="keyword">return</span> ::std::any&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>构造函数的参数是一个指向类中成员函数的指针，在这里，我们使用了可变参数模板，代表成员函数可以接纳任意数量的参数。</p>
<p>这里的<code>function</code>依旧是一个<code>std::function&lt;::std::any(::std::any)&gt;</code>类型的函数容器，我们实际去调用成员函数的过程就是在调用<code>function</code>。为了使<code>function</code>可以传入多个参数，可以考虑使用C++11中的可变参数元组<code>std::tuple</code>作为<code>std::any</code>的指代对象，因此，我们可以写出如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> tuple = ::std::tuple&lt;Class&amp;, Args...&gt;;</span><br><span class="line">tuple* pTuple = ::std::<span class="built_in">any_cast</span>&lt;tuple*&gt;(objArgs);</span><br><span class="line">::std::<span class="built_in">apply</span>(func, *pTuple);</span><br></pre></td></tr></table></figure>
<p><code>std::apply</code>是在C++17中引入的功能，它的作用是将传入一个函数包装和一个参数（这个参数可以是<code>std::tuple</code>，<code>std::array</code>或<code>std::pair</code>），并将这个参数当作函数的实参去调用函数，当apply的那个函数是非静态成员函数时，我们必须为其指定实例，而这个实例就放在tuple的第一个位置，这也就是为什么要写成<code>std::tuple&lt;Class&amp;, Args...&gt;</code>的形式。</p>
<p>由于该函数无返回值，所以最后返回一个空的<code>std::any&#123;&#125;</code>。</p>
<p><strong>无返回值，const成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(<span class="type">void</span> (Class::* func)(Args...) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">	function = [<span class="keyword">this</span>, func](::std::any objArgs) -&gt; ::std::any &#123;</span><br><span class="line">		<span class="keyword">using</span> tuple = ::std::tuple&lt;<span class="type">const</span> Class&amp;, Args...&gt;;</span><br><span class="line">		tuple* pTuple = ::std::<span class="built_in">any_cast</span>&lt;tuple*&gt;(objArgs);</span><br><span class="line">		::std::<span class="built_in">apply</span>(func, *pTuple);</span><br><span class="line">		<span class="keyword">return</span> ::std::any&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	isConst = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里除了使用常量引用<code>const Class&amp;</code>和设置<code>isConst</code>标志以外，和上述代码并无区别。</p>
<p><strong>有返回值，非const成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Return, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(Return (Class::* func)(Args...))</span> </span>&#123;</span><br><span class="line">	function = [<span class="keyword">this</span>, func](::std::any objArgs) -&gt; ::std::any &#123;</span><br><span class="line">		<span class="keyword">using</span> tuple = ::std::tuple&lt;Class&amp;, Args...&gt;;</span><br><span class="line">		tuple* pTuple = ::std::<span class="built_in">any_cast</span>&lt;tuple*&gt;(objArgs);</span><br><span class="line">		<span class="keyword">return</span> ::std::<span class="built_in">apply</span>(func, *pTuple);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个新的模板类型作为返回值类型，同时将执行<code>std::apply</code>得到的值返回出去。</p>
<p><strong>有返回值，const成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Return, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(Return (Class::* func)(Args...) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">	function = [<span class="keyword">this</span>, func](::std::any objArgs) -&gt; ::std::any &#123;</span><br><span class="line">		<span class="keyword">using</span> tuple = ::std::tuple&lt;<span class="type">const</span> Class&amp;, Args...&gt;;</span><br><span class="line">		tuple* pTuple = ::std::<span class="built_in">any_cast</span>&lt;tuple*&gt;(objArgs);</span><br><span class="line">		<span class="keyword">return</span> ::std::<span class="built_in">apply</span>(func, *pTuple);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	isConst = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Invoke函数：</strong></p>
<p>在调用构造函数后，我们已经将<code>function</code>存储在了<code>MemberFunction</code>类当中，接下来我们需要一个调用<code>function</code>的方法，于是编写一个Invoke函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Class</span>, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">::<span class="function">std::any <span class="title">Invoke</span><span class="params">(Class&amp; obj, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isConst) &#123;</span><br><span class="line">		<span class="keyword">auto</span> argsTuple = ::std::<span class="built_in">make_tuple</span>(::std::<span class="built_in">reference_wrapper</span>&lt;<span class="type">const</span> Class&gt;(obj), args...);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">function</span>(&amp;argsTuple);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> argsTuple = ::std::<span class="built_in">make_tuple</span>(::std::<span class="built_in">reference_wrapper</span>&lt;Class&gt;(obj), args...);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">function</span>(&amp;argsTuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用万能引用的方式传入了参数包，然后将该参数包再次用<code>std::make_tuple</code>包装成了tuple传入<code>function</code>中，完成了调用。</p>
<p>注意这里在包装参数时用到了<code>std::reference_wrapper&lt;Class&gt;</code>，它是一个引用的包装器，行为和<code>Class&amp;</code>类似，但是不同的是它可以被拷贝或复制。在使用<code>std::make_tuple</code>的时候默认会把每个参数进行一次拷贝，将其转化为原始值类型，而使用<code>std::reference_wrapper</code>进行包装可以规避掉拷贝，从而确保传入的值是引用。</p>
<p>另一个需要注意的点是，当函数参数出现引用时，考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> ::std::string&amp; str)</span> </span>&#123; ::std::cout &lt;&lt; str &lt;&lt; ::std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">reflect::MemberFunction <span class="title">func</span><span class="params">(&amp;Foo::Func)</span></span>;</span><br><span class="line"></span><br><span class="line">	::std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Foo foo;</span><br><span class="line">	func.<span class="built_in">Invoke</span>(foo, str);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在进行Invoke时会抛出<code>bad_any_cast</code>异常，原因是上面说过的<code>std::make_tuple</code>会将参数转化为原始值类型，因此这里的<code>argsTuple</code>类型为<code>std::tuple&lt;Foo&amp;, ::std::string&gt;</code>，与成员函数所期望的<code>std::tuple&lt;Foo&amp;, const ::std::string&amp;&gt;</code>不符，无法进行<code>std::any_cast</code>转换，解决方案是使用<code>std::ref</code>和<code>std::cref</code>规定传入的值为引用，将上述代码修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="built_in">Invoke</span>(foo, ::std::<span class="built_in">cref</span>(str));</span><br></pre></td></tr></table></figure>
<h3 id="优化：ArgWrap包装参数">优化：ArgWrap包装参数</h3>
<p>使用<code>std::ref</code>和<code>std::cref</code>手动指定引用有时会带来不必要的错误，因此利用一个ArgWrap中间层对其进行包装是十分必要的，ArgWrap的基本功能是实现值和引用的双向映射。</p>
<p>考虑值类型和左值引用两种情况，此处用到了模板的特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RefTrait</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RefTrait</span>&lt;T&amp;&gt; &#123;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑非const和const两种情况，设非const为假，const为真：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span> : ::std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span>&lt;T&amp;&gt; : ::std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span>&lt;T*&gt; : ::std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span>&lt;<span class="type">const</span> T&gt; : ::std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span>&lt;<span class="type">const</span> T&amp;&gt; : ::std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConst</span>&lt;<span class="type">const</span> T*&gt; : ::std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ArgWrap</code>类的基本结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArgWrap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="title">ArgWrap</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">		refType = RefTrait&lt;T&gt;::value;</span><br><span class="line">		isConst = IsConst&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (refType == <span class="number">1</span>) &#123;</span><br><span class="line">			storage = &amp;value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			storage = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	T <span class="title">Cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> refType&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">bool</span> isConst&#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	::std::any storage&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>refType</code>代表存储的值的具体类型（值或引用），<code>isConst</code>代表存储的值类型是否具有常量限定符。如果传入的是值类型，那么存储值本身；如果传入的是引用，那么存储值的地址。</p>
<p>向<code>Cast</code>函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RawT = ::std::<span class="type">remove_cv_t</span>&lt;::std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> castRefType = RefTrait&lt;T&gt;::value;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> castIsConstant = IsConst&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>std::move_reference</code>用于将引用类型还原为值类型，<code>std::move_reference_t&lt;T&gt;</code>与<code>std::remove_reference&lt;T&gt;::value</code>同义。</p>
</blockquote>
<blockquote>
<p><code>std::move_cv</code>用于去掉类型的<code>const</code>限定符和<code>volatile</code>限定符，<code>std::remove_cv_t&lt;T&gt;</code>与<code>std::remove_cv&lt;T&gt;::value</code>同义。</p>
</blockquote>
<p><code>castRefType</code>代表转换的具体类型（值或引用），<code>castIsConst</code>代表转换的类型是否具有常量限定符。由于模板实例是在编译期创建的，所以此处的代码都用<code>constexpr</code>修饰，放在编译期处理。</p>
<p>考虑以下几种不同的Cast转换情形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(castRefType == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (refType == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//引用类型转换为值类型</span></span><br><span class="line">		<span class="keyword">if</span> (isConst)</span><br><span class="line">			<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> RawT*&gt;(storage);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;RawT*&gt;(storage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//值类型转换为值类型</span></span><br><span class="line">	<span class="keyword">return</span> ::std::<span class="built_in">any_cast</span>&lt;RawT&gt;(storage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值类型转换为引用类型</span></span><br><span class="line"><span class="keyword">if</span> (refType == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;RawT&gt;(&amp;storage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型转换为引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(castIsConstant)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isConst)</span><br><span class="line">		<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> RawT*&gt;(storage);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;RawT*&gt;(storage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isConst) &#123;</span><br><span class="line">		<span class="comment">//无法将常量引用转换为非常量引用</span></span><br><span class="line">		<span class="keyword">throw</span> ::std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Cannot cast const ref to non-const ref&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *::std::<span class="built_in">any_cast</span>&lt;RawT*&gt;(storage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写一个<code>AsTuple</code>函数，以array作为传入参数构建tuple：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args, <span class="type">size_t</span> N, <span class="type">size_t</span>... Is&gt;</span><br><span class="line">::<span class="function">std::tuple&lt;Args...&gt; <span class="title">AsTuple</span><span class="params">(::std::array&lt;ArgWrap, N&gt;&amp; array, ::std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ::std::forward_as_tuple(array[Is].<span class="built_in">Cast</span>&lt;Args&gt;()...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args, <span class="type">size_t</span> N, <span class="keyword">typename</span> = ::std::<span class="type">enable_if_t</span>&lt;N == <span class="keyword">sizeof</span>...(Args)&gt;&gt;</span><br><span class="line">::std::tuple&lt;Args...&gt; <span class="built_in">AsTuple</span>(::std::array&lt;ArgWrap, N&gt;&amp; array) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">AsTuple</span>&lt;Args...&gt;(array, ::std::<span class="built_in">make_index_sequence</span>&lt;N&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AsTuple</code>的第一个重载提供了两个整型的模板参数<code>N</code>和<code>Is</code>，其中<code>N</code>指定了模板参数包<code>Args</code>的参数个数，<code>Is</code>是一个用<code>std::index_sequence</code>填充的参数包。</p>
<blockquote>
<p><code>std::index_sequence</code>和<code>std::make_index_sequence</code>是C++14提供的一个模板元编程工具，作用是产生用作编译期常量的整数序列，此处我们用它来生成索引。</p>
</blockquote>
<p>用<code>std::forward_as_tuple</code>将参数包<code>Args</code>中的每一个参数都经过Cast之后转发为tuple。</p>
<p><code>AsTuple</code>的第二个重载是第一个重载的一个接口，我们实际使用时就是调用的这一个重载。</p>
<blockquote>
<p><code>std::enable_if_t</code>是C++14提供的一个模板元编程工具，与<code>std::enable_if&lt;&gt;::type</code>同义，作用是使类型在满足条件时有效，这里只是单纯用来确保<code>N</code>和<code>Args</code>的参数个数匹配。</p>
</blockquote>
<p>完成了<code>ArgWrap</code>类的构建，改写原来的<code>MemberFunction</code>构造函数中的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">argsNum = <span class="keyword">sizeof</span>...(Args);</span><br><span class="line"></span><br><span class="line">function = [<span class="keyword">this</span>, func](<span class="type">void</span>* argsPtr) -&gt; ::std::any &#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; args = *<span class="keyword">static_cast</span>&lt;::std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + <span class="number">1</span>&gt;*&gt;(argsPtr);</span><br><span class="line">	<span class="keyword">auto</span> tp = <span class="built_in">AsTuple</span>&lt;Class&amp;, Args...&gt;(args);</span><br><span class="line">	</span><br><span class="line">	::std::<span class="built_in">apply</span>(func, tp);</span><br><span class="line">	<span class="keyword">return</span> ::std::any&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用一个<code>argsNum</code>来存储成员函数应传入的参数个数。<code>function</code>的参数从<code>std::any</code>改成了<code>void*</code>，实际上传入的是被包装为array的参数（array的大小为<code>sizeof...(Args) + 1</code>，因为还要塞一个类实例进去），通过<code>AsTuple</code>转换为tuple，最后再通过<code>std::apply</code>调用。</p>
<p>改写原来的<code>MemberFunction::Invoke</code>中的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argsNum != <span class="keyword">sizeof</span>...(Args)) &#123;</span><br><span class="line">	<span class="keyword">throw</span> ::std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Mismatching number of arguments&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + 1&gt; argsArray = &#123;</span><br><span class="line">	<span class="built_in">ArgWrap</span>(obj),</span><br><span class="line">	<span class="built_in">ArgWrap</span>(std::forward&lt;Args&gt;(args))...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">function</span>(&amp;argsArray);</span><br></pre></td></tr></table></figure>
<p>首先判断传入的参数个数是否准确，否则抛出异常。</p>
<p>将输入的参数用数组包装起来，这里使用了<code>std::forward</code>去实现参数包转发，通过C++17的折叠表达式展开了<code>ArgWrap</code>构造函数。最后将<code>argsArray</code>用指针的方式传入<code>function</code>中完成调用。</p>
<p>有了以上的铺垫，以后在调用Invoke时就可以实现值类型和引用类型的自动转换，不用任何<code>std::ref</code>或<code>std::cref</code>。</p>
<h3 id="写入全局注册表">写入全局注册表</h3>
<p>构建一个<code>RawTypeDescriptorBuilder</code>类来将反射信息写入注册表中，类的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RawTypeDescriptorBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">RawTypeDescriptorBuilder</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span></span>;</span><br><span class="line">	<span class="built_in">RawTypeDescriptorBuilder</span>(<span class="type">const</span> RawTypeDescriptorBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">RawTypeDescriptorBuilder</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Var&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">AddMemberVariable</span><span class="params">(<span class="type">const</span> ::std::string&amp; name, Var Class::* var)</span> </span>&#123;</span><br><span class="line">		<span class="function">MemberVariable <span class="title">variable</span><span class="params">(var)</span></span>;</span><br><span class="line">		var.name = name;</span><br><span class="line">		desc-&gt;memberVars.<span class="built_in">push_back</span>(var);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">AddMemberFunction</span><span class="params">(<span class="type">const</span> ::std::string&amp; name, Func Class::* func)</span> </span>&#123;</span><br><span class="line">		<span class="function">MemberFunction <span class="title">function</span><span class="params">(func)</span></span>;</span><br><span class="line">		function.name = name;</span><br><span class="line">		desc-&gt;memberFuncs.<span class="built_in">push_back</span>(function);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	::std::unique_ptr&lt;TypeDescriptor&gt; desc&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将<code>RawTypeDescriptorBuilder</code>设为<code>TypeDescriptor</code>，<code>MemberVariable</code>和<code>MemberFunction</code>的友元类，以便访问这些类中的私有成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RawTypeDescriptorBuilder</span>;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，新建一个<code>TypeDescriptor</code>实例，并设置类名字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RawTypeDescriptorBuilder::<span class="built_in">RawTypeDescriptorBuilder</span>(<span class="type">const</span> ::std::string&amp; name)</span><br><span class="line">	: <span class="built_in">desc</span>(::std::<span class="built_in">make_unique</span>&lt;TypeDescriptor&gt;()) &#123;</span><br><span class="line">	desc-&gt;name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在析构函数中，将<code>TypeDescriptor</code>实例添加到注册表中，同时销毁<code>RawTypeDescriptorBuilder</code>中的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RawTypeDescriptorBuilder::~<span class="built_in">RawTypeDescriptorBuilder</span>() &#123;</span><br><span class="line">	Registry::<span class="built_in">Instance</span>().<span class="built_in">Register</span>(::std::<span class="built_in">move</span>(desc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RawTypeDescriptorBuilder</code>类上再封装一层<code>TypeDescriptorBuilder</code>，采用类模板定义，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Class</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeDescriptorBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">TypeDescriptorBuilder</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> : rawBuilder(name) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Var&gt;</span></span><br><span class="line"><span class="function">	TypeDescriptorBuilder&amp; <span class="title">AddMemberVariable</span><span class="params">(<span class="type">const</span> ::std::string&amp; name, Var Class::* var)</span> </span>&#123;</span><br><span class="line">		rawBuilder.<span class="built_in">AddMemberVariable</span>(name, var);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">	TypeDescriptorBuilder&amp; <span class="title">AddMemberFunction</span><span class="params">(<span class="type">const</span> ::std::string&amp; name, Func Class::* func)</span> </span>&#123;</span><br><span class="line">		rawBuilder.<span class="built_in">AddMemberFunction</span>(name, func);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	RawTypeDescriptorBuilder rawBuilder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类中的<code>AddMemberVariable</code>和<code>AddMemberFunction</code>函数都返回一个实例自身的引用，这是为了方便以这样的形式调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reflect::<span class="built_in">AddClass</span>&lt;Foo&gt;(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">	.<span class="built_in">AddMemberVariable</span>(<span class="string">&quot;var&quot;</span>, &amp;Foo::var)</span><br><span class="line">	.<span class="built_in">AddMemberFunction</span>(<span class="string">&quot;Func&quot;</span>, &amp;Foo::Func);</span><br></pre></td></tr></table></figure>
<p>用<code>AddClass</code>函数去实际上创建出一个<code>TypeDescriptorBuilder</code>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Class&gt;</span></span><br><span class="line"><span class="function">TypeDescriptorBuilder&lt;Class&gt; <span class="title">AddClass</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TypeDescriptorBuilder</span>&lt;Class&gt;(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Get</code>函数获取存储了所有反射信息的vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;TypeDescriptor*&gt; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Registry::<span class="built_in">Instance</span>().<span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>GetByName</code>函数去查找一个已经添加到注册表中的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TypeDescriptor&amp; <span class="title">GetByName</span><span class="params">(<span class="type">const</span> ::std::string&amp; name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *Registry::<span class="built_in">Instance</span>().<span class="built_in">Find</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码演示了这个反射系统的使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	reflect::<span class="built_in">AddClass</span>&lt;Foo&gt;(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">		.<span class="built_in">AddMemberVariable</span>(<span class="string">&quot;str&quot;</span>, &amp;Foo::str)</span><br><span class="line">		.<span class="built_in">AddMemberFunction</span>(<span class="string">&quot;Func&quot;</span>, &amp;Foo::Func);</span><br><span class="line"></span><br><span class="line">	Foo foo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> str = reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>).<span class="built_in">GetMemberVariable</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">	str.<span class="built_in">SetValue</span>&lt;::std::string&gt;(foo, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; str.<span class="built_in">GetValue</span>&lt;std::string&gt;(foo) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>).<span class="built_in">GetMemberFunction</span>(<span class="string">&quot;Func&quot;</span>).<span class="built_in">Invoke</span>(foo);</span><br><span class="line">	std::cout &lt;&lt; reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>).<span class="built_in">GetMemberFunction</span>(<span class="string">&quot;Func&quot;</span>).<span class="built_in">IsConst</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码渲染">代码渲染</h2>
<p>我们构建的运行时反射工具需要手动用<code>AddClass</code>去添加反射信息，小项目还好，假如是在一个庞大的工程当中，每次都要手动添加信息就太过繁琐了，因此我们可以考虑设计一个自动解析源代码并生成反射代码的系统，这套自动生成代码的系统就称作<strong>代码渲染（Code rendering）</strong>。因为Clang可以参考的资料相对较多，所以在这里我们选择Clang去做这个工作。</p>
<h3 id="Clang-AST">Clang AST</h3>
<p>Clang是一个开源的C++编译前端，作为LLVM的一部分，它提供了一些接口能够帮助我们解析C++代码。安装完LLVM开发环境后，在Shell中输入以下命令行代码以dump出source.hpp的AST：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -ast-dump -fsyntax-only source.hpp</span><br></pre></td></tr></table></figure>
<p>AST（Abstract syntax tree，抽象语法树）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，不同的编译器都有各自的AST实现方式，Clang的AST结构大概长这样：</p>
<p><img src="/images/articles/cpp_reflection/image_0.png" alt="Clang AST 结构"></p>
<p>简单介绍一下AST常用节点类型的意义：</p>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TranslationUnitDecl</td>
<td>Clang AST的顶层节点，遍历AST实际上就是对TranslationUnitDecl的子节点进行遍历</td>
</tr>
<tr>
<td>CompoundStmt</td>
<td>代码块，函数实现、struct、enum、for的body一般会用它包起来</td>
</tr>
<tr>
<td>DeclStmt</td>
<td>定义语句，VarDecl等类型的定义一般会用它包起来</td>
</tr>
<tr>
<td>VarDecl</td>
<td>变量定义语句</td>
</tr>
<tr>
<td>MethodDecl</td>
<td>函数定义语句</td>
</tr>
<tr>
<td>FieldDecl</td>
<td>成员变量定义语句</td>
</tr>
<tr>
<td>IfStmt</td>
<td>if语句，包括Cond、TrueBody、FalseBody三部分。</td>
</tr>
<tr>
<td>ForStmt</td>
<td>for语句</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>一元操作符</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>二元操作符，包括=、&gt;、&lt;、&lt;=、&gt;=、==等各种二元操作</td>
</tr>
<tr>
<td>ImplicitCastExpr</td>
<td>隐式转换表达式</td>
</tr>
<tr>
<td>CallExpr</td>
<td>函数调用表达式</td>
</tr>
<tr>
<td>ReturnStmt</td>
<td>函数返回语句</td>
</tr>
<tr>
<td>ParenExpr</td>
<td>括号表达式</td>
</tr>
<tr>
<td>TypedefDecl</td>
<td>类型转换语句，如遇指针类型会内建PointerType和BuiltinType实现转换</td>
</tr>
<tr>
<td>RecordDecl</td>
<td>class或struct的定义，使用InitExpr或InitListExpr初始化成员</td>
</tr>
<tr>
<td>AccessSpecDecl</td>
<td>类的public、private、protected访问权限</td>
</tr>
<tr>
<td>Constructor、Destructor</td>
<td>类的构造与析构函数</td>
</tr>
<tr>
<td>Literal</td>
<td>不同类型的字面量，包含IntegerLiteral和FloatingLiteral等</td>
</tr>
</tbody>
</table>
<h3 id="LibClang解析工具">LibClang解析工具</h3>
<p>LibClang库使我们能在C++程序中使用Clang的功能，只需<code>#include &quot;clang-c\Index.h&quot;</code>，并且链接相关的lib和dll。</p>
<p>从以下代码开始我们的解析工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; arguments = &#123;</span><br><span class="line">	<span class="string">&quot;c++&quot;</span>,</span><br><span class="line">	<span class="string">&quot;-std=c++17&quot;</span></span><br><span class="line">	<span class="string">&quot;-D __clang__&quot;</span>,</span><br><span class="line">	<span class="string">&quot;-D __META_PARSER__&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> translator = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">	index, <span class="string">&quot;source.hpp&quot;</span>, arguments.<span class="built_in">data</span>(), (<span class="type">int</span>)arguments.<span class="built_in">size</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line"><span class="keyword">if</span> (!translator) &#123;</span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to parse translation unit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clang_disposeTranslationUnit</span>(translator);</span><br><span class="line"><span class="built_in">clang_disposeIndex</span>(index);</span><br></pre></td></tr></table></figure>
<p>在调用<code>clang_parseTranslationUnit</code>时，可以传入<code>command_line_args</code>命令行参数，这里我们主要用它来定义编译器宏，比如这里的<code>__META_PARSER__</code>宏就告诉程序此时我们是在进行解析工作。</p>
<p>在<code>clang_parseTranslationUnit</code>成功完成后，我们将得到source.hpp解析出的AST，之后的工作就是遍历和检查AST。</p>
<p>Cursors对象是指向AST的指针，通过以下方法获取翻译单元的Cursor：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rootCursor = <span class="built_in">clang_getTranslationUnitCursor</span>(translator);</span><br></pre></td></tr></table></figure>
<p>重载&lt;&lt;运算符用于将parse出的<code>CXString</code>信息打印出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetClangString</span><span class="params">(<span class="type">const</span> CXString&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> c_str = <span class="built_in">clang_getCString</span>(str);</span><br><span class="line">	<span class="built_in">clang_disposeString</span>(str);</span><br><span class="line">	<span class="keyword">return</span> c_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> CXString&amp; str) &#123;</span><br><span class="line">	<span class="keyword">auto</span> c_str = <span class="built_in">GetClangString</span>(str);</span><br><span class="line">	stream &lt;&lt; c_str;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过遍历Cursor的子节点将Cursor指向的信息和节点的类型打印出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> childVisitor = [](CXCursor cursor, CXCursor parent, CXClientData data) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Kind: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; <span class="built_in">clang_getCursorKindSpelling</span>(<span class="built_in">clang_getCursorKind</span>(cursor)) &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;Cursor: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; <span class="built_in">clang_getCursorSpelling</span>(cursor) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">clang_visitChildren</span>(rootCursor, childVisitor, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>解析的source.hpp的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> field&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行解析程序，可以看到控制台中已经能打印出AST信息了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Kind:            ClassDecl      Cursor:              MyClass</span><br><span class="line">Kind:   CXXAccessSpecifier      Cursor:</span><br><span class="line">Kind:            CXXMethod      Cursor:                 Func</span><br><span class="line">Kind:         CompoundStmt      Cursor:</span><br><span class="line">Kind:             DeclStmt      Cursor:</span><br><span class="line">Kind:              VarDecl      Cursor:                    a</span><br><span class="line">Kind:       IntegerLiteral      Cursor:</span><br><span class="line">Kind:            FieldDecl      Cursor:                field</span><br><span class="line">Kind:         InitListExpr      Cursor:</span><br><span class="line">Kind:       IntegerLiteral      Cursor:</span><br></pre></td></tr></table></figure>
<p>现在我们来考虑以下问题：AST所包含的信息是很多的，我们只需要获得反射要用到的信息就够了，具体的实现方法就是打上Clang的编译器标记：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="built_in">annotate</span>(<span class="string">&quot;reflect-infomation&quot;</span>)))</span><br></pre></td></tr></table></figure>
<p>修改source.hpp的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __META_PARSER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> META __attribute__((annotate(<span class="string">&quot;reflect-class&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROPERTY() __attribute__((annotate(<span class="string">&quot;reflect-property&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNCTION() __attribute__((annotate(<span class="string">&quot;reflect-function&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> META</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROPERTY()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNCTION()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">META</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PROPERTY</span>()</span><br><span class="line">	<span class="type">int</span> field&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们就成功在<code>MyClass</code>，<code>Func</code>和<code>field</code>处打入了三个标记，再次运行解析程序，可以发现我们输入的annotate信息已经出现在了Cursor处。</p>
<p>在Shell中对修改后的source.hpp进行dump，AST结构看起来是这样的：</p>
<p><img src="/images/articles/cpp_reflection/image_1.png" alt=""></p>
<p>我们也可以用<code>__VA_ARGS__</code>可变参数宏来传入一些额外的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROPERTY(...) __attribute__((annotate(<span class="string">&quot;reflect-property;&quot;</span> #__VA_ARGS__)))</span></span><br></pre></td></tr></table></figure>
<p>接下来要做的就是通过标记找到有用的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> childVisitor = [](CXCursor cursor, CXCursor parent, CXClientData data) &#123;</span><br><span class="line">	<span class="keyword">auto</span> cursors = <span class="keyword">reinterpret_cast</span>&lt;std::vector&lt;CXCursor&gt;*&gt;(data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(cursor) == CXCursor_AnnotateAttr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetClangString</span>(<span class="built_in">clang_getCursorSpelling</span>(cursor)) == <span class="string">&quot;reflect-class&quot;</span>) &#123;</span><br><span class="line">			cursors-&gt;<span class="built_in">push_back</span>(parent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;CXCursor&gt; metaCursors;</span><br><span class="line"><span class="built_in">clang_visitChildren</span>(rootCursor, childVisitor, <span class="built_in">reinterpret_cast</span>&lt;CXClientData&gt;(&amp;metaCursors));</span><br></pre></td></tr></table></figure>
<p>找到类型为<code>CXCursor_AnnotateAttr</code>的Cursor，访问父节点<code>parent</code>找到我们需要的Cursor，通过传入一个<code>CXClientData</code>指针可以把我们要用的Cursor节点取出。</p>
<h3 id="生成代码">生成代码</h3>
<p>用<code>MetaData</code>来盛装需要的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MetaData</span> &#123;</span><br><span class="line">	std::string key;</span><br><span class="line">	std::string value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::vector&lt;MetaData&gt;&gt; metaData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cursor : metaCursors) &#123;</span><br><span class="line">	<span class="keyword">auto</span> visitor = [](CXCursor cursor, CXCursor parent, CXClientData data) &#123;</span><br><span class="line">		<span class="keyword">auto</span> rawData = <span class="keyword">reinterpret_cast</span>&lt;std::vector&lt;MetaData&gt;*&gt;(data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(cursor) == CXCursor_AnnotateAttr) &#123;</span><br><span class="line">			MetaData meta;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_FieldDecl)</span><br><span class="line">				meta.key = <span class="string">&quot;field&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_CXXMethod)</span><br><span class="line">				meta.key = <span class="string">&quot;method&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line"></span><br><span class="line">			meta.value = <span class="built_in">GetClangString</span>(<span class="built_in">clang_getCursorSpelling</span>(parent));</span><br><span class="line">			</span><br><span class="line">			rawData-&gt;<span class="built_in">push_back</span>(meta);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;MetaData&gt; data;</span><br><span class="line">	<span class="built_in">clang_visitChildren</span>(cursor, visitor, <span class="built_in">reinterpret_cast</span>&lt;CXClientData&gt;(&amp;data));</span><br><span class="line"></span><br><span class="line">	metaData[<span class="built_in">GetClangString</span>(<span class="built_in">clang_getCursorSpelling</span>(cursor))] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以source.hpp为例，我们生成一个source.generated.hpp，向里面写入注册反射的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reflection.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;source.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_Ref</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyClass_Ref</span>() &#123;</span><br><span class="line">		reflect::<span class="built_in">AddClass</span>&lt;MyClass&gt;(<span class="string">&quot;MyClass&quot;</span>)</span><br><span class="line">			.<span class="built_in">AddMemberVariable</span>(<span class="string">&quot;field&quot;</span>, &amp;MyClass::field)</span><br><span class="line">			.<span class="built_in">AddMemberFunction</span>(<span class="string">&quot;Func&quot;</span>, &amp;MyClass::Func);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>自动生成以上代码的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* header = &#123;<span class="string">&quot;\</span></span><br><span class="line"><span class="string">#include \&quot;reflection.hpp\&quot;\n\</span></span><br><span class="line"><span class="string">#include \&quot;source.hpp\&quot;\n\</span></span><br><span class="line"><span class="string">\n\</span></span><br><span class="line"><span class="string">&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MetaCompiler <span class="title">compiler</span><span class="params">(<span class="string">&quot;../source/source.hpp&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> metaData = compiler.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">output</span><span class="params">(header)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [key, value] : metaData) &#123;</span><br><span class="line">	output += <span class="string">&quot;class &quot;</span> + key + <span class="string">&quot;_Ref &#123;\n&quot;</span>;</span><br><span class="line">	output += <span class="string">&quot;public:\n&quot;</span>;</span><br><span class="line">	output += <span class="string">&quot;\t&quot;</span> + key + <span class="string">&quot;_Ref() &#123;\n&quot;</span>;</span><br><span class="line">	output += <span class="string">&quot;\t\treflect::AddClass&lt;&quot;</span> + key + <span class="string">&quot;&gt;(\&quot;&quot;</span> + key + <span class="string">&quot;\&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; member : value) &#123;</span><br><span class="line">		output += <span class="string">&quot;\n\t\t\t.AddMember&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (member.key == <span class="string">&quot;field&quot;</span>)</span><br><span class="line">			output += <span class="string">&quot;Variable&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (member.key == <span class="string">&quot;method&quot;</span>)</span><br><span class="line">			output += <span class="string">&quot;Function&quot;</span>;</span><br><span class="line"></span><br><span class="line">		output += <span class="string">&quot;(\&quot;&quot;</span> + member.value + <span class="string">&quot;\&quot;, &amp;&quot;</span> + key + <span class="string">&quot;::&quot;</span> + member.value + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	output += <span class="string">&quot;;\n\t&#125;\n&#125;;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;../source/source.generated.hpp&quot;</span>, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">file &lt;&lt; output;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<h2 id="序列化">序列化</h2>
<p><strong>序列化（Serialization）</strong> 是将对象的状态信息转换为可以存储或传输的形式的过程，通常我们会将实例数据以可被读取的字节数组存入静态数据文件中，一个常规的选择就是JSON。</p>
<p>基于JSON的C++序列化/反序列化已经有很多现成的库，我们不必重复造轮子。此处我选择的是 <a target="_blank" rel="noopener" href="https://github.com/nlohmann/json">https://github.com/nlohmann/json</a> ，一个基于C++11的轻量级JSON读写库，是纯头文件的形式，使用只需<code>#include&lt;nlohmann/json.hpp&gt;</code>，非常方便。</p>
<p>下面介绍一下这个库的基本语法：</p>
<p>该库中的JSON对象以<code>nlohmann::json</code>类型存储。</p>
<p>用<code>fstream</code>从文件中读入JSON数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nlohmann::json metadata;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;metadata.json&quot;</span>)</span></span>;</span><br><span class="line">in &gt;&gt; metadata;</span><br><span class="line">in.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>用<code>fstream</code>向文件中写入JSON数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;metadata.json&quot;</span>)</span></span>;</span><br><span class="line">out &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; metadata;</span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>读出JSON中的键值对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="keyword">auto</span> str = metadata[<span class="string">&quot;str&quot;</span>].<span class="built_in">get</span>&lt;std::string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line">std::string str;</span><br><span class="line">metadata[<span class="string">&quot;str&quot;</span>].<span class="built_in">get_to</span>(str);</span><br></pre></td></tr></table></figure>
<p>该库提供了类似STL容器和迭代器的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON数组</span></span><br><span class="line">metadata[<span class="string">&quot;array&quot;</span>] = &#123; <span class="string">&quot;meta_0&quot;</span>, <span class="string">&quot;meta_1&quot;</span> &#125;;</span><br><span class="line">metadata[<span class="string">&quot;array&quot;</span>].<span class="built_in">push_back</span>(<span class="string">&quot;meta_2&quot;</span>);</span><br><span class="line">metadata[<span class="string">&quot;array&quot;</span>].<span class="built_in">emplace_back</span>(<span class="string">&quot;meta_3&quot;</span>);</span><br><span class="line">metadata[<span class="string">&quot;array&quot;</span>].<span class="built_in">erase</span>(<span class="string">&quot;meta_3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON对象</span></span><br><span class="line"><span class="keyword">if</span> (metadata[<span class="string">&quot;object&quot;</span>].<span class="built_in">find</span>(<span class="string">&quot;data&quot;</span>) != metadata.<span class="built_in">end</span>()) &#123;</span><br><span class="line">	metadata[<span class="string">&quot;object&quot;</span>][<span class="string">&quot;data&quot;</span>].<span class="built_in">get_to</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : metadata) &#123;</span><br><span class="line">	std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++17</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : metadata.<span class="built_in">items</span>()) &#123;</span><br><span class="line">	std::cout &lt;&lt; key &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑我们要序列化的类结构，可以写出以下JSON结构：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;MyClass&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;obj1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.25</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;str&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;obj2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">3.0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;str&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Another object!&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>构建一个序列化<code>Serializer</code>工具类，该类的基本结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">const</span> std::string&amp; filePath, nlohmann::json&amp; metadata)</span> </span>&#123;</span><br><span class="line">		<span class="function">std::ifstream <span class="title">in</span><span class="params">(filePath)</span></span>;</span><br><span class="line">		in &gt;&gt; metadata;</span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> std::string&amp; filePath, <span class="type">const</span> nlohmann::json&amp; metadata)</span> </span>&#123;</span><br><span class="line">		<span class="function">std::ofstream <span class="title">out</span><span class="params">(filePath)</span></span>;</span><br><span class="line">		out &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; metadata;</span><br><span class="line">		out.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">static</span> <span class="type">void</span> <span class="title">Serialize</span><span class="params">(<span class="type">const</span> T&amp; obj, nlohmann::json&amp; metadata)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">static</span> <span class="type">void</span> <span class="title">Deserialize</span><span class="params">(T&amp; obj, <span class="type">const</span> nlohmann::json&amp; metadata)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>Serialize</code>和<code>Deserialize</code>是留空的模板函数，对于不同类的序列化和反序列化方法，我们可以为其进行对应的模板特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Serializer::Serialize</span><span class="params">(<span class="type">const</span> MyClass&amp; obj, nlohmann::json&amp; metadata)</span> </span>&#123;</span><br><span class="line">	metadata.<span class="built_in">at</span>(<span class="string">&quot;fields&quot;</span>)[<span class="string">&quot;value&quot;</span>] = obj.value;</span><br><span class="line">	metadata.<span class="built_in">at</span>(<span class="string">&quot;fields&quot;</span>)[<span class="string">&quot;str&quot;</span>] = obj.str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Serializer::Deserialize</span><span class="params">(MyClass&amp; obj, <span class="type">const</span> nlohmann::json&amp; metadata)</span> </span>&#123;</span><br><span class="line">	metadata.<span class="built_in">at</span>(<span class="string">&quot;fields&quot;</span>).<span class="built_in">at</span>(<span class="string">&quot;value&quot;</span>).<span class="built_in">get_to</span>(obj.value);</span><br><span class="line">	metadata.<span class="built_in">at</span>(<span class="string">&quot;fields&quot;</span>).<span class="built_in">at</span>(<span class="string">&quot;str&quot;</span>).<span class="built_in">get_to</span>(obj.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过特化后就可以直接使用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nlohmann::json metadata;</span><br><span class="line">Serializer::<span class="built_in">Read</span>(<span class="string">&quot;metadata.json&quot;</span>, metadata);</span><br><span class="line"></span><br><span class="line">MyClass obj1;</span><br><span class="line">Serializer::<span class="built_in">Deserialize</span>(obj1, metadata[<span class="string">&quot;MyClass&quot;</span>][<span class="string">&quot;obj1&quot;</span>]);</span><br><span class="line"></span><br><span class="line">MyClass obj2;</span><br><span class="line">Serializer::<span class="built_in">Deserialize</span>(obj2, metadata[<span class="string">&quot;MyClass&quot;</span>][<span class="string">&quot;obj2&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>如果觉得为每一个类都进行对应的模板特化太过繁琐，也可以考虑将其纳入自动生成的范畴，和上面自动生成反射代码类似，写起来也并不难，这里不再过多赘述。</p>
<p>以上，做好了反射和序列化的工作后，我们对C++的掌控就更加全面了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://illurin.github.io">Illurin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://illurin.github.io/articles/cpp_reflection/">https://illurin.github.io/articles/cpp_reflection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://illurin.github.io" target="_blank">缪之灵</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1/">游戏引擎设计</a></div><div class="post_share"><div class="social-share" data-image="/images/articles/cpp_reflection/image_1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/articles/linear-algebra03/"><img class="prev-cover" src="/images/articles/cover_6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">矩阵代数（二）：秩与线性方程组</div></div></a></div><div class="next-post pull-right"><a href="/articles/linear-algebra04/"><img class="next-cover" src="/images/articles/cover_6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">矩阵代数（三）：特征值与二次型</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Illurin</div><div class="author-info__description">缪之灵的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Illurin"><i class="fab fa-github"></i><span>关注我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Illurin" target="_blank" title="Github"><i class="fa-brands fa-github-alt"></i></a><a class="social-icon" href="https://www.zhihu.com/people/96-61-29-67" target="_blank" title="知乎"><i class="fa-brands fa-zhihu"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%8D%E5%B0%84"><span class="toc-number">1.</span> <span class="toc-text">运行时反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">创建全局注册表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%88Type-Erasure%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">类型擦除（Type Erasure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">反射成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">反射成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9AArgWrap%E5%8C%85%E8%A3%85%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">优化：ArgWrap包装参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">写入全局注册表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B8%B2%E6%9F%93"><span class="toc-number">2.</span> <span class="toc-text">代码渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clang-AST"><span class="toc-number">2.1.</span> <span class="toc-text">Clang AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LibClang%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">LibClang解析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">生成代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">序列化</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra04/" title="矩阵代数（三）：特征值与二次型"><img src="/images/articles/cover_6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（三）：特征值与二次型"/></a><div class="content"><a class="title" href="/articles/linear-algebra04/" title="矩阵代数（三）：特征值与二次型">矩阵代数（三）：特征值与二次型</a><time datetime="2022-12-24T15:31:00.000Z" title="发表于 2022-12-24 23:31:00">2022-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/cpp_reflection/" title="使用模板技巧和LibClang实现简易C++静态反射系统"><img src="/images/articles/cpp_reflection/image_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用模板技巧和LibClang实现简易C++静态反射系统"/></a><div class="content"><a class="title" href="/articles/cpp_reflection/" title="使用模板技巧和LibClang实现简易C++静态反射系统">使用模板技巧和LibClang实现简易C++静态反射系统</a><time datetime="2022-12-16T12:30:00.000Z" title="发表于 2022-12-16 20:30:00">2022-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra03/" title="矩阵代数（二）：秩与线性方程组"><img src="/images/articles/cover_6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（二）：秩与线性方程组"/></a><div class="content"><a class="title" href="/articles/linear-algebra03/" title="矩阵代数（二）：秩与线性方程组">矩阵代数（二）：秩与线性方程组</a><time datetime="2022-12-02T00:38:00.000Z" title="发表于 2022-12-02 08:38:00">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra02/" title="矩阵代数（一）：行列式与矩阵求逆"><img src="/images/articles/cover_6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="矩阵代数（一）：行列式与矩阵求逆"/></a><div class="content"><a class="title" href="/articles/linear-algebra02/" title="矩阵代数（一）：行列式与矩阵求逆">矩阵代数（一）：行列式与矩阵求逆</a><time datetime="2022-12-02T00:37:00.000Z" title="发表于 2022-12-02 08:37:00">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/linear-algebra01/" title="线性空间与线性变换概念浅析"><img src="/images/articles/cover_6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性空间与线性变换概念浅析"/></a><div class="content"><a class="title" href="/articles/linear-algebra01/" title="线性空间与线性变换概念浅析">线性空间与线性变换概念浅析</a><time datetime="2022-11-29T12:00:00.000Z" title="发表于 2022-11-29 20:00:00">2022-11-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/articles/cpp_reflection/image_1.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Illurin</div><div class="footer_custom_text">Never give up your dream.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>